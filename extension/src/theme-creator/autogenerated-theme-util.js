/**
 * @license
 * Copyright 2019 The Chromium Authors
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 *
 * Source: chromium/src/main/chrome/common/themes/autogenerated_theme_util.cc
 *
 * Ported by VannRR <https://github.com/vannrr> 2025
 */

import {
  blendForMinContrast,
  getColorWithMaxContrast,
  getContrastRatioFloat,
  getContrastRatioArgb,
  getRelativeLuminance,
  hSLToArgb,
  isDark,
  argbToHSL,
} from "./color-utils";
import { ARGB_WHITE } from "./argb";

const kAutogeneratedThemeActiveTabMinContrast = 1.3;
const kAutogeneratedThemeActiveTabPreferredContrast = 1.6;
const kAutogeneratedThemeActiveTabPreferredContrastForDark = 1.7;
const kAutogeneratedThemeTextPreferredContrast = 7.0;

/**
 * @typedef {Object} AutogeneratedThemeColors
 * @property {number} frameColor         Packed ARGB for the frame background.
 * @property {number} frameTextColor     Packed ARGB for text in the frame.
 * @property {number} activeTabColor     Packed ARGB for the active tab background.
 * @property {number} activeTabTextColor Packed ARGB for text in the active tab.
 * @property {number} ntpColor           Packed ARGB for the new-tab-page background.
 */

/**
 * Decrease lightness by `change` (0..1). Returns original color if resulting
 * lightness would be < 0 to avoid producing invalid HSL.
 *
 * @param {number} color  Packed ARGB color.
 * @param {number} change Amount to subtract from lightness (0..1).
 * @returns {number}      New packed ARGB color.
 */
function darkenColor(color, change) {
  const hsl = argbToHSL(color);
  hsl.l -= change;
  if (hsl.l < 0.0) {
    return color;
  }
  return hSLToArgb(hsl, 0xff);
}

/**
 * Increase the lightness of `source` until one of:
 *   - contrast between `base` and candidate ≥ contrast_ratio, OR
 *   - contrast between white and candidate ≥ white_contrast
 *
 * Binary-searches lightness in [originalℓ, 1.0] to ~0.01 precision.
 *
 * @param {number} source          Packed ARGB to lighten.
 * @param {number} base            Packed ARGB to test contrast against.
 * @param {number} contrast_ratio  Target contrast ratio against `base`.
 * @param {number} white_contrast  Max allowed contrast ramp toward white.
 * @returns {number}               New packed ARGB after lightening.
 */
function lightenUntilContrast(source, base, contrast_ratio, white_contrast) {
  const baseLuminance = getRelativeLuminance(base);
  const kWhiteLuminance = 1.0;

  const hsl = argbToHSL(source);
  let minL = hsl.l;
  let maxL = 1.0;

  while (maxL - minL > 0.01) {
    hsl.l = minL + (maxL - minL) / 2;
    const candidate = hSLToArgb(hsl, 0xff);
    const candidateLum = getRelativeLuminance(candidate);

    const meetsBaseContrast =
      getContrastRatioFloat(baseLuminance, candidateLum) >= contrast_ratio;
    const exceedsWhiteContrast =
      getContrastRatioFloat(kWhiteLuminance, candidateLum) < white_contrast;

    if (meetsBaseContrast || exceedsWhiteContrast) {
      maxL = hsl.l;
    } else {
      minL = hsl.l;
    }
  }

  hsl.l = maxL;
  return hSLToArgb(hsl, 0xff);
}

/**
 * Generate theme colors that meet the contrast requirements for Firefox.
 *
 * @param {number} argb Base packed ARGB color.
 * @returns {AutogeneratedThemeColors}
 */
export function getAutogeneratedThemeColors(argb) {
  let frameColor = argb;
  let frameTextColor;
  let activeTabColor = argb;
  let activeTabTextColor;

  const kDarkenStep = 0.03;
  const kMinWhiteContrast = 1.3;
  const kNoWhiteContrast = 0.0;
  const kMaxLuminosityForDark = 0.05;

  while (true) {
    frameTextColor = getColorWithMaxContrast(frameColor);

    const blendTarget = getColorWithMaxContrast(frameTextColor);
    frameColor = blendForMinContrast(
      frameColor,
      frameTextColor,
      blendTarget,
      kAutogeneratedThemeTextPreferredContrast,
    ).color;

    activeTabColor = lightenUntilContrast(
      frameColor,
      frameColor,
      kAutogeneratedThemeActiveTabMinContrast,
      kNoWhiteContrast,
    );

    const frameHsl = argbToHSL(frameColor);
    const preferredContrast =
      frameHsl.l <= kMaxLuminosityForDark
        ? kAutogeneratedThemeActiveTabPreferredContrastForDark
        : kAutogeneratedThemeActiveTabPreferredContrast;

    activeTabColor = lightenUntilContrast(
      activeTabColor,
      frameColor,
      preferredContrast,
      kMinWhiteContrast,
    );

    if (
      getContrastRatioArgb(frameColor, activeTabColor) <
      kAutogeneratedThemeActiveTabMinContrast
    ) {
      frameColor = darkenColor(frameColor, kDarkenStep);
      continue;
    }

    activeTabTextColor = getColorWithMaxContrast(activeTabColor);

    if (!isDark(activeTabColor)) {
      activeTabColor = lightenUntilContrast(
        activeTabColor,
        activeTabTextColor,
        kAutogeneratedThemeTextPreferredContrast,
        kNoWhiteContrast,
      );
      break;
    }

    if (
      getContrastRatioArgb(activeTabColor, ARGB_WHITE) >=
      kAutogeneratedThemeTextPreferredContrast
    ) {
      break;
    }

    frameColor = darkenColor(frameColor, kDarkenStep);
  }

  return {
    frameColor,
    frameTextColor,
    activeTabColor,
    activeTabTextColor,
    ntpColor: activeTabColor,
  };
}
